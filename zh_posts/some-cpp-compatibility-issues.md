---
title: 从 C++ 兼容性引发的一些思考
date: 2016-03-17 10:20:05
categories:
- chit-chat
tags:
- C++
- Java
- compatibility
---

> 注意：本文只是讨论几个从最近遇到的C++兼容性问题联想到的几点细微的想法，并不是一份完整的从 C++ 标准到平台和编译器实现之间的详细对比

# 前言

自从上个学期修了 Java 课，而且受那位优秀的老师兼优秀的工程师的薰陶下，不仅对 Java 黑转路，甚至还隐隐地有点接纳“Java 臃肿的表现即是其简洁的本质的表达”这样的理念了。不过理解归理解，要我在自己里的项目里用 Java，估计还是不乐意的，敲字符的时间也是时间不是么。

然后时间就到了这个月初，因为密码学作业的缘故，又重新拿起了 C++ ，做了一个简单的某经典密码的破解程序。这是一个本体实现不到200行，加上测试代码各种框架不超过2000行的小项目，然而就是这么一个小项目，却让我遇到了不少的移植性方面的麻烦。在处理这一系列相对来说陌生的问题，面对这些从来没面对过的困难的时候，无意中就对一些以前根本没注意过的语言设计方面的问题收获了一些新的认识，这也引发了我对 C++ 和 Java 这两门语言的重新审视。
<!--more-->

从 BSD 到 Linux，相信任何人都不会认为这其中会有很多兼容性问题，更何况这里讲的兼容性还是源码的兼容性。即便当时还不怎么有概念，我开始项目的时候，还是有意识地特地选择了经过了多年考验的 C++11 标准，心想用这么个老标准，怎么着也应该没什么大问题才对嘛。

# 出现问题

这次出场的两个编译器分别是：

```
$ clang --version
Apple LLVM version 7.0.2 (clang-700.1.81)
Target: x86_64-apple-darwin15.3.0
Thread model: posix
```
和
```
$ gcc --version
gcc (Ubuntu 5.2.1-22ubuntu2) 5.2.1 20151010
```

同样是采用 C++11 标准，从实际的编译结果来看，二者之间还是存在了好些区别。总体而言，clang 对代码的限制要少得多，大部分时候你随便折腾代码，在 clang 下也竟然都能通过。然而在 gcc 下就完全不是这么一回事了。在这次 gcc 编译的过程中，我发现的 clang 相对 gcc 宽松的地方有：

## namespace
clang 对 namespace 非常不挑剔，比如对于从某 namespace 派生出来的类，clang 支持：
```cpp
using namespace ns;

// where Type is declared in ns
template <> struct Type<sth> {...};
```
而 gcc 则要显式指定 `ns::Type`。

对于成员函数的定义，同样地，clang 也支持
```cpp
using namespace ns;
using namespace std;

ostream& operator<<(ostream& o, Type<sth> t) {...}
```
gcc 则同样需要显式指定。

## implicit coercion
clang 能通过：
```cpp
if (argv[0] == "something") {...}
```
而 gcc 则需要显式转换为 string。

上面两个例子给我的感觉就是，虽然 clang 提供的特性非常方便也符合直觉，但是正因为 C++ 标准里很多模糊地带的存在，我们为了可移植性的考虑，就会更倾向于选用最严格的限制。这样我们在使用这门语言的时候不仅不能够享受这些特性带来的好处，反而让那些灵活的编译器成为了滋生不兼容代码的温床。

C++ 标准里面很多的中间地带都是源于历史上的妥协。比如对于基本类型 int，竟然只限制了最小范围。这确实是对当时的各大平台各大事实编译器体现了尊重，然后呢？C++ 程序员便不再信任这个类型，彻底抛弃掉用 `int32_t` 替代。所以说何必呢，你堂堂一个语言标准，定义的基本类型却是不可移植的，逼得各厂商自行寻求解决方案，那要你这标准何用？就算就算你 C++ 要考虑底层性能考虑 wrap 的代价，你在设计标准的时候，也应该是以一个 virtual machine 的角度来看，来选定标尺，而不应该是依据现存的这些个实现。到头来委员会又采纳回了工业界的事实标准，足足绕了一个大圈子。相对之下，Java 在标准层面就提供的 VM 角度和平台无关基本类型，确实是经得起推敲的设计。

另外一个典型的例子，就是 C++ 和 Java 里的异常了。尽管它们都提供 `throws` 关键字，但是却是可选的。好了，模糊地带形成。于是编译器厂商在面对这个问题的时候，就只能从最严格情况考虑，即使某构造函数并不抛出异常，还是要硬塞各种异常发生后的析构代码，等于处理异常的成本分摊到语言的方方面面。而受害者一方为了还原原本的性能，还要靠自己声明 `noexcept` 来实现，这简直了。我的感觉就是，一个有洞的方案，还不如没有方案。

## default parameters

这个问题的出现确实完全刷新了我对 Java 这一设计的看法。在此之前，我一直认为 Java 不提供默认参数是一件死板迂腐到不能再迂腐的事情。即使 Google C++ Coding Style 里给出了“默认参数可能会掩盖 API，最后消失在大部分程序员的记忆里”这一比“降低可读性”更强硬的理由，还是不能说服我。我会反驳说默认参数可以提供比现有的好得多的解决方案来解决这些问题。第一个“掩盖API”的问题，完全可以通过现代的代码补全功能完美解决，第二个可读性的问题，其实可以参考 Ruby 的 Hash options 的语法设计，在代码规范里做一些强制，比如在当年 MFC 自动生成的模板代码里，我们可以看到类似这样的函数调用：

```cpp
foo(para1, para2, /* para3 = */ para3)
```

看上去变繁琐了，实际上这样的设置，作成 snippets 或者是通过类似 clang-format 的工具，都是相对容易自动化的事情。

不过会产生这样的设计方案，就必定预示着原始方案在某些工程实践的场景下失灵了。幸运地，我确实发现了这样一个例子。这样一个问题就是 -- 标准库函数的默认参数取值，竟然没有被规定好（`std::async`）！又是一个有洞的方案...... 然后它产生问题就当然是必然的啦，同样的代码，在不同的编译器编译后，行为却因为默认值的不同而不同。估计有人会说，这个 `async` 依赖系统线程的实现，所以默认值不确定是很正常的嘛。可是，竟然这样的话，为，毛，要，设，置，默认参数啊！这种场景就不是适用默认参数的场景啊。

道理就是这样，如果只考虑默认参数这一设计本身，我会认为缺陷不大或者都可以克服。但是这也经不住会有上游作者在不该用默认参数的时候乱用，产生不可预知的移植性问题。不管怎么说，我已经能够说服自己 Java 禁用默认函数的设计是能够理解的了。

不过我还是不能理解 Java 不提供操作符重载的考虑是什么，希望未来也会有类似的例子打我脸。不过操作符这个方面嘛，我觉得应该不会有的了。

# This is engineering

我相信如果把过往所有引发类似问题的例子列出来，一定会是一个相当长的列表。不过这其实正是工程界的本质 -- 我们的程序，都是建立在充满了 bugs 和 flaws 的代码基础之上的。这其中让我印象最深刻的，就是上学期 Java 课上所演示的，当 ArrayList 的 size 为2的时候，多线程重写元素不抛异常的 bug。这可是在标准库里的 non-trivial 方法啊！就是这么一个 bug，从报出来一直到现在 Java 8，从未听说它被修复过。然后老师当时还顺便把 JVM 的 bug 跟踪列表展示给我们看了。讲真，看完之后，特别是上面那个例子之后，我就对工业界的这么些 code base 的状况，有一个比较形象的认识了。（同时也对自己写出来的 bug 表示更加宽容了（笑））

当然，它所带来的不仅仅是形象的认识。通过它，你会对如何写出一份健壮代码形成自己的思考，并在判断各语言语法，库函数的设计是否恰当的问题上，产生自己的理解，进而内化为一种直觉。正因为工程界唯一关心的事情就是 getting things done，当我们在思考这是否是一个良好的语言设计的时候，我们永远也不能从理论层面得到答案，真正的好的设计，永远是在实践中被总结出来的。

