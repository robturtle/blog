---
title: 我们为什么需要版本管理和虚拟环境
date: 2016-07-30
tags:
- methodology
---

# 版本管理

原因在于软件开发的特性：它是一个持续演化的过程。在软件演化的过程中，它其实产生的是一系列随时间发布的独立应用。各个应用之间并不保证有任何相互的联系。不过从业务逻辑一致的角度说，它们有很大的可能是相似；另外有些厂做的向后兼容做的太好了让人看不出这个差别。但我们依然要清楚一点，不同版本的应用本质上说就是独立的两个软件了。对于一个依赖于软件 a 的 1 版本开发出来的上层应用，当把它的依赖转移到软件 a 的其他版本时，我们很难判定上层应用是否还能够继续正常运行。

<!-- more -->

这还是单一依赖的情况，当我们的依赖变多时，就会出现一些很复杂的情形。 典型的有循环依赖问题，以及依赖冲突问题。比如我的软件 a 依赖于 b 和 c，b 依赖于 x 并要求 x 版本不得高于 3, c 也依赖于 x 并要求 x 版本不得低于 4 。对于这些依赖问题的解决能力的强弱便决定了一款版本管理软件的好坏。

# 虚拟环境

循环依赖的问题可以直接在拓扑的层面解决，现在关心一下冲突依赖的问题。在每个同名的软件只允许同时存在一份的版本管理系统下面，这样的冲突问题就没法解决。但就如同我们上面说的一样，不同版本的同名软件本质上就是不同的，只是他们恰好名字相同而已。对两个不同的软件加上只允许一个存在的限制，显然不合理嘛！

解决方法本来很简单，就是两个都装上就好了，但是因为版本管理在某种程度上不够标准化，另外就是以前的遗留应用并没有对依赖的明确指定。出于向后兼容的目的，我们还是得在明面上保留一个同名软件只能存在一份的限制。那怎么解决呢？简单啊，祭出软件行业里的万能解决方案 — 加一个间接层不就搞定了嘛！

## sandbox

第一种方案，我们为每个软件都提供一个自己专属的本地环境，把它们的底层依赖都放进里面，这样子， b 就能很愉快地在自己的环境里使用版本 2 的 x，又不会和使用版本 4 的 c 产生冲突。问题解决了。

仔细想想，这样的一种模式是不是似曾相识？考虑一下我们是怎么实现进程模型的？我们给每个进程一个本地的环境，保存了它依赖的寄存器状态等上下文。这样，其实相当于给每个进程提供了一个虚拟的本地 CPU ，进程都各自独立运行在自己的虚拟 CPU 上而不互相干扰。

这种模式同时还带来一个相对正面的副作用，那就是隔离。因为它们各自的环境不同，a 在它的虚拟环境下做的改变，就没法对其他的运行者可见了。为了让它们各自能够交流，所以他们在进程基础上还得开发诸如 IPC 的沟通协议。它的正面则表现在，所有的潜在破坏也被隔离在本地虚拟环境下了。除非是虚拟环境提供者本身的 bug ，在虚拟环境的破坏永远也不可能扩散到外部去。

> 不过现在的好些版本管理提供沙盒的能力都是。。。直接物理拷贝。。。额。。 有点蠢。这点上比较严重的是 npm ，它导致的一个严重问题就是在主机资源不够的情况下 npm install 就直接失败了。。败了。。了。。 (且不说我的 VPS 上可是已经有账面 1G 的内存) 对资源的这种不合理的要求，的确是 npm 最能体现它的“现代”性的地方了。
> 
> 对于这种不聪明的沙盒方案，我们显然可以通过提供全局的能理解版本含义的仓库来解决。不过这就需要把 local storage 和 Inter-Sandbox Communication 的问题给解决好才行。在模块管理的领域里，相当是又一次发明了动态链接库。
> 
> 另外对于线程的概念，Linus 说这个模型是 broken 的。个人表示认同。你为了实现相互通信就简单粗暴地在沙盒上捅一个洞，然后为了堵上你漏洞，搞出各种各样同步，锁之类的幺蛾子。简直就是没事找事。这就叫你不尊重规则，规则也不尊重你。

## stubs / shims

这里讲的是版本管理怎么样在明面里还继续维持一个名字对应一个应用的规定。版本管理软件对每一个应用来说，并不是直接地提供应用本体，而是提供一个可能具备自动检查及搭建环境，自动解决依赖，自动判定启用版本的程序。我们称为 stub 或者 shim （两者有些许的意义差异，我的理解大致来说，stub 更偏向于搭建环境，shim 则更偏向于版本选用的语义）。

一个很常见的例子就是 OS X 下的一系列 dev-tools (gcc, java, git, etc.)。它们就是一个 stub ，当你没安装 dev-tools 的时候，调用它的作用就是安装 dev-tools, 当你安装好之后，调用它的作用就是选用合适版本的应用启动它。安装好后这个 java 程序就是一个 shim 了，所以你可以方便地在 OS X 系统全局切换默认的 jdk。

这里举 ruby 版本管理软件 rbenv 的例子，看看它是怎么管理版本的：

```shell
▶ rbenv versions
  system
  2.1.10
* 2.3.1 (set by /Users/yangliu/.rbenv/version)

▶ which gem
/Users/yangliu/.rbenv/shims/gem

▶ cat `which gem`
#!/usr/bin/env bash
set -e
[ -n "$RBENV_DEBUG" ] && set -x

program="${0##*/}"
if [ "$program" = "ruby" ]; then
  for arg; do
    case "$arg" in
    -e* | -- ) break ;;
    */* )
      if [ -f "$arg" ]; then
        export RBENV_DIR="${arg%/*}"
        break
      fi
      ;;
    esac
  done
fi

export RBENV_ROOT="/Users/yangliu/.rbenv"
exec "/usr/local/Cellar/rbenv/1.0.0/libexec/rbenv" exec "$program" "$@"
```

## polyfill

讲了那么多向后兼容，现在看看 polyfill。简单来说，polyfill 相当于给一个老系统装上一个插件，让它实现对新系统的向前兼容的能力。举个特别老的例子，就是老的 MS Word 是不支持数学公式编辑的，但是新的版本的可以。微软就提供了一个插件，让老的 Word 程序装上之后也能够具备相应的能力。

不过 polyfill 这个概念被发明已经火起来还是这几年的事情了，这得益于现在前端正在进行的如火如荼的前端工程化运动。可以说 jQuery 就是一个最早的 polyfill 库了。而现在最为引人注目的自然是为 ES5- js 提供 ES 6+ 能力的 babel polyfill 了。 可以预测，polyfill 这一领域将会越来越受重视，它给业界带来的改变将会是越来越便捷迅速的软件升级过程，像以前 XP ，IE 6 一用用十年的现象将不复存在。

> 在这过程中 jQuery 承担了非常沉重的历史包袱，导致的结果就是越来越多的人开始嫌弃它的臃肿了。于是现在我知道的，就已经有好几个组织和公司正在开发 jQuery 的 polyfill 了。真是天道好轮回啊。

# 现状

从以前的批量式发布，到敏捷发布，到现在的持续发布，版本发布的频率越来越大。版本造成的问题也将被不断放大。可以想见，冲突积累到一定时候，一定又会产生一批新的流行的解决方案的。不过在此之前，在我们进行持续发布的实践中，从一开始就遵循常见的版本约定，人人有责。比如开发一个 npm package，就要严格遵循它的版本约定，而不至于当你明明发布了一个 API 不兼容的版本却没有切换主版本号时，被一堆兼容问题淹没了你的 issues 页面。
