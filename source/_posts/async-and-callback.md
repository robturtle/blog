---
title: 异步与回调
date: 2016-11-30 21:33:50
tags:
- multi-threading
- async
- callback
---

## 同步

之前有人在知乎上提问说，”[为什么 CPU 内部需要时钟](https://www.zhihu.com/question/21981280)“。从这个答案我们就能知道，CPU 只是数字电路，并不一定需要时钟。只不过具备时钟的 CPU 比较容易被设计出来，所以才常见 CPU 具备时钟。从微观角度来看，CPU 内部的每个组件，乃至组件内部，都是不分先后各种运行的。但从功能的角度来说，我们时常需要一个明确的运行顺序来收获可预知的结果。一个最简单的例子就是对寄存器的写操作，我们希望让 WriteEnable 信号，写入地址，和写入值这三种信号同时输入进寄存器芯片里，以期实现正确的写操作。为了达到目的，我们把这三个输入阻断在一个锁存器上，当时钟的上升沿到达的时候同时释放。这样就达到了让输入同步的目的了。而这，就是就原始的同步(synchronization) 的含义了。反之，当不存在这样的同步结构的时候，系统就是异步(asynchronous)的。

<!-- more -->

在原始的含义的基础上，同步还具有一个重要的引申义，即一个同步的结构强制了它附近一个唯一的执行顺序。这个是因为同步信号由时钟控制，那么被同步执行的命令在时间轴上就必将具备确定的执行顺序了。

因为绝大部分的计算机体系被设计为同步的，而 C 语言又是对硬件的抽象，所以在 C 的语境里，同步的属性就是自然而然的了。考虑下面的类 C 代码：

```c

void a() { print('a'); c(); d(); }
void b() { print('b'); }
void c() { print('c'); }
void d() { print('d'); }

int main()
{
  a();
  b();
  c();
}
```

它所描述的，实际就是一个确定的同步执行命令。任何时候，一定是先执行完 a，再去执行 b。而对 a 来说，则必须将它内部的命令递归地同步执行完才能看做结束。

我们可以很容易地发现，在 C 里面的每一个所谓的 function ，实际上描述的就是一个按深度优先顺序展开的命令树。如下图：

![](https://www.dropbox.com/s/myqy6h6cotssng3/call-tree.png?raw=1)

因为这个命令树的展开顺序是确定的，我们可以很容易地发现，如果我们把原函数用它的函数体按这种顺序进行替换展开，展开后的函数，和原来的函数是等价的。也即上面的代码，和下面这段代码是等价的：

```c
int main()
{
  print('a');
  print('c');
  print('d');
  print('b');
  print('c');
}
```

> 考虑一下你会如何深度优先遍历一棵树？是不是想到了要用栈？对了，我们的所谓调用栈(call stack)，实际上就是为了遍历这棵树而使用的辅助数据结构。

这就是由同步的计算机体系带来的同步的 C 语言带来的同步的编程语言的语义。我们也称这样的编程范式为：命令式 (imperative)。

## 异步

许多人因为习惯了这样的一种同步的编程语言的思维惯性，在初次面对异步的概念的时候往往就会自己掉坑里面。但我们要时刻谨记一点，编程语言的范式绝不止命令式这一种。

考虑一下，在已有同步模型的情况下，我们为什么还要引入异步？其实有个事实在一开始就提出来了，从硬件的层面看，系统天然就是异步的，同步是为了正确性人为强加的。同步也带来了性能上的开销，在摩尔定律失效的多核时代里，尽量让更多的组件互不掣肘来达到更高性能的要求显得越发重要。而无视这种性能损失的人，虽然运气好时能赚钱，但依然要被用户吐槽，被专家鞭尸打脸（比如目前正被微软用 C++ 重写的 [Minecraft](https://www.zhihu.com/question/24459078))。

现在假设我们的计算机里拥有许多个互不干扰的运算核心，而我们的运算任务也不关心内部各部分的执行快慢，那么在我们拿到类似上面那样的代码的时候。对函数的执行就不是用上面的“深度优先展开”的方式了。这个时候，情况更像是主调用者站在树的根部 main 的位置，依次向 a, b 和 c 发送了一个顺丰小哥，然后在 main 这个点上就完事了。而被派发出去的各个小哥，在到达目的地后，也将递归地向更下层的每个节点派发新的小哥。考虑每个小哥都是放在一个独立的运算核心上进行的，而各核心的运算速度总会有不确定，这就必然导致最后整个运算任务的执行结果的不确定性。

这种模型在处理各自独立的任务的时候的确很美好，但现实的情况是，真实的需求里，只有部分任务是独立的，还有部分任务是依赖于其他任务的结果的，这就要求我们在异步的模型上重新引入同步。

这个问题并没有一眼看上去那么好解决。在前面的命令式范式中，我们可以很容易根据自己在深度优先遍历的所在位置去定位下一个需要执行的任务。在异步模型中，假设 B 任务依赖于 A 任务的结果，那么计算机如何确定何时 A 已经结束可以去执行 B 了呢？

> 以下的代码示例均为伪代码， global 代表该模块全局可见，singleton 代表该模块全局仅有一个

### 轮询

第一种方式最为简单，B 死循环每隔固定时间就去检查一遍 A 的结果，直到结果就绪才跳出循环，这个方案因为引入了大量的无效运算，基本在上层软件应用的层面上已经基本淘汰。

```javascript
global bool A_is_ready = false;
global int A_result;

function A() {
  A_result = 1 + 1;
  A_is_ready = true;
}

function B() {
  while (true) {
    if (A_is_ready) break;
    sleep(1000_ms);
  }
  print(A_result);
}
```



### 消息系统

消息系统的本质就是一个“生产者-消费者”模型，系统提供一个全局的阻塞队列(blocking queue)，一般由一个消息管理者将不同的“消息”派发给指定的消息订阅者。订阅者在平时没有任务也没有消息的时候直接休眠，当对应消息来的时候，才会被唤醒，进行指定的任务。

```javascript
global BlockingQueue messageQueue;
global function messageDispatcher() {
  while (true) {
    wait whenever messageQueue.empty();
    msg = messageQueue.deque();
    for (subscriber in subscribers[msg.type]) wake(subscriber, msg.type);
  }
}

global int result;

function A() {
  result = 1 + 1;
  messageQueue.enque(Message(type = 'A_is_ready'));
}

function B() {
  subscribers['A_is_ready'] = this;
  wait for Message of type 'A_is_ready'
  print(result);
}
```

上面的代码，只需要做一些抽象上的包装，就会变成我们常见到的消息系统了。

```javascript
global int reault;

class A extends Messager {
  run() {
    result = 1 + 1;
    this.emit('A_is_ready');
  }
}

class B extends Messager {}

B.once('A_is_ready', function() {
  print(result);
})

B.start_watching();
A.run();
```

## 回调函数

其实在最后的例子里面，我们已经离回调函数很接近了。在上面的例子里，当 A 就绪的时候，B 都需要去一个全局的位置来找需要的结果。这种对全局变量的滥用，必将会带来维护性上的噩梦。为了改进这种情况，我们考虑到，其实在 A 的内部，A 是知道数据的所在的，只是 B 不知道罢了。我们或许可以设计一种方法，把 B 托付给 A，让 A 在感觉合适的时机，把合适的值通过参数的方式传递给 B 并调用它，这样就解决了 A 与 B 之间的消息传递而又不需要用上全局函数了。

这便是回调的做法，我们将 B 整个的运算逻辑作为参数传递给 A ，此时可以看做是传给了 A 一个封存好的机器，机器并不立刻运转，直到 A 将物料准备就绪投入机器中，A 才主动开启机器。也就是 B 作为一个函数被调用的时机，已经不是由 B 的提供者来决定而是由 A 来钦定。从调用者的视角来看，就是 caller 主动调用 A 并传递 B 给 A，A 拥有对 B 的调用的主动权。此即控制反转（IoC) 。

```javascript
function A(callback_logic) {
  result = 1 + 1;
  callback_logic(result);
}

function B(value) {
  print(value);
}

A(B);
```

### 后续传递风格 (Continuation-passing Style)

> 注：关于这个名词的中文翻译我并不确定

CPS 可以说是和命令式范式恰好相反的一种范式了。在命令式范式中，每个独立的操作之间默认是同步的，当我们需要异步的时候，我们便需要一些特殊的机制来达成（如线程，如协程，等）。而如果在一个大多数操作默认都是异步的系统里面，我们如果需要同步，同样需要一些特殊的机制。这其中最有名(臭名昭著？)的机制是 Monad, 其次便是 CPS。

> 其实不管 Monad 也好， CPS 也好，它们都只是一种设计模式而已。理解这种模式也许不会吸引你去写默认异步的编程语言，但它却令人惊奇地能让你在写命令式的语言的时候写的更优雅整洁。
>
> 其中一个很明显的例子就是使用 Monad 模式来避免裹臭脚长舌妇一般的 defensive 错误处理逻辑。

现在我们假设有一种语言 AsyncScript，它的函数内部是顺序执行的，但对所有的函数调用都是异步执行的。在这样的一个语言环境里，我希望让函数 A, B, C 按确定的顺序来执行，如何做呢？

最简单的方式就是使用上面提到的回调函数咯，在 A 结束时回调 B，在 B 结束时回调 C。如此我们便通过回调函数实现了同步。这种设计模式便是 CPS。

```javascript
function A(nextOne) {
  print('execute at order 1');
  nextOne();
}

function B(nextOne) {
  print('execute at order 2');
  nextOne();
}

function C(nextOne) {
  print('execute at order 3');
  nextOne();
}

A(function () {
  B(function () {
    C(function () {/* do nothing */ });
  });
});
```

想必很多人在写 node.js 的时候都不自觉地写出了这样的 CPS 设计模式来达到同步的效果。但我们对比一下命令式范式里的等价用法：

```java
// meanwhile in imperative languages
A();
B();
C();
```

显然我们会发现在这种情况下，默认同步的语言写起来要优雅得多，而前者一旦当嵌套层次多了之后，可读性呈指数下降直到落入 [Callback Hell](http://callbackhell.com/)。

### 异步中实现同步的语法糖

稍有计算机常识的人都知道，任何一个图灵完全的机器都是相互等价的，也就是说，CPS 和命令式范式在理论层面上只是写法有区别。既然如此，我们在希望通过异步来增强系统性能的同时，我们也希望通过一些方便的语法糖来在异步中实现同步。

其中一个在库层面被实现出来的机制便是 Promise。它其实就是把 CPS 中的一层嵌套包裹在了 OO 的包装里，其本质还是上面的 CPS，只不过通过成员函数的包装，变得更为可读。

```javascript
new Promise(A).next(B).next(C).get();
```

看上去已经不错了，但 Promise 对程序员并不是透明的，程序员依然需要调用 `Promise::get` 之类的函数来启动它，同时原本只是为了表达同步顺序的简单概念却引入了这么多包装，从可读性上来说也不是最佳选择。

于是乎，一个比较优秀的解法，就应该是从语法层面入手，通过基本模拟命令式范式的写法来写异步中的同步。我们用 async 关键字来标记默认异步执行的函数，用 await 来表示一重的 CPS 关系。

```javascript
async function A() {
  print('execute at order 1');
}

async function B() {
  print('execute at order 2');
}

async function C() {
  print('execute at order 3');
}

await A();
await B();
await C();
```

## 结语

对异步编程范式的熟悉需要过程，但其中最重要的，是要始终牢记在两种范式间对函数调用的不用含义。在同步的语义下，函数调用时指将对应函数在原地按深度优先展开并顺序执行；而在异步语义下，函数调用只是将函数委托给他方执行，委托完成即立刻返回执行后续的语句。此时被委托执行的函数和主函数互为并发。

在命令式范式里常见的具备异步语义的函数有 `thread` 等，在 node.js 里，函数是否异步有时不能从函数名称来判断，但是，一般来说异步的函数都会接受回调函数作为参数。因为这样才能支持 CPS 范式，便于在 node.js 常见的“请求-回复”消息循环里处理被回复的数据。
