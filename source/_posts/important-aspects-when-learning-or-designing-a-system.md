---
title: 学习/设计一个新系统时，我们该关注些什么？
date: 2016-07-09 16:16:56
tags:
- methodology
---

这里的系统是指一个广义上具备交互能力的体系，可以是一门编程语言，也可以是一个应用框架。


## 学习一个新系统时我们该关注些什么？

按重要性从高到低排序。

### 资源仓库 (repository)

系统的资源仓库构成了系统的生态系统。如果系统是一个厨房的话，那么资源仓库就是装满了食材的冰箱，资源就是各式食材。如果我们想要充分利用系统的能力，找到冰箱所在并学会如何取用需要的食材便是必不可少的第一步。比如：

- 各式语言的专门库/应用仓库：gems for Ruby, pip for Python, npm for Node.js, ...
- 通用的代码仓库：Github, Bitbucket, ...

<!-- more -->

### 规范 (code)

规范决定了系统内部的合作成本的高低。这里合作既可能是同项目内不同模块间的，也可能是不同项目间的，或者是项目模块于系统模块间的。在遵循规范的前提下，我们才可能提出 convention over configuration 的模式，使不同项目间的相似逻辑得以在架构层面重用。

对于常见编程语言而言，如果有工具辅助规范检查则是极好的，比如：

- ClangFormat for C family languages
- ESLint for JavaScript

### 查错 (troubleshooting)

当学习者掌握了在系统中定位错误能力之后，学习者才算真正具备在系统中存活并且自主学习的能力。

对于常见编程语言的查错来说，有几个基本能力是跨语言通用的：

- 查看 call stack 的能力
- 读懂常见错误定位的格式。比如 `at Module._compile (module.js:541:32)` ，就要清楚， at 后的字段代表了调用的方法名，括号里的文件名后跟的两个冒号间隔开的两个数字分别代表在文件里的行号和列号。

广义上讲，所有的查错过程其实都是在某个或具象或虚拟的 call stack 上回溯直至定位到错误原点的过程。比如今天我在学习 Puppet Quick Start 的文档时，按照它的操作使用 `apache` 模块时出错。因为此时没有 call stack，用户就必须根据出错信息手动回溯。具体过程如下：

```shell
puppet apply site.pp # 错误，提示在 systemctl status apache2.service 里追溯
systemctl status apache2.service # 显示 start 时出错，出错时正在进行 config test 
apache2ctl configtest # 发现是因为 MPM 不能同时存在两个或以上
a2dismod worker # 最终的排错方案
```

除了第一步因为 `systemd` 的良好提示之外，后几步的回溯基本上都是靠着搜索引擎的帮助，一步步逼近发生问题的位置，并得到解决方案。另外我们看到两点：

- 当我们把回溯的步骤打印出来之后，它就是一个虚拟的 call stack 形式
- 这种简洁的形式概括了从错误的发现地到源头的路径以及查错的具体过程

即是说这样寥寥 4 行 shell 命令便是一种精简的记录格式，具备错误事件的高度概括性以及排错过程的复现能力。这样一种追溯错误的能力是如此可迁移以致大多数时候可以让排错者忽略错误无关的细节。比如此时我只期望把 demo 跑通而不是去学习 apche 相关，所以当我最终排错完成之后，我依然可以不知道 MPM  是个什么东西。

### 测试 (testing)

测试保证了你个人构建的逻辑前提的置信度。尤其是测试驱动的开发（TDD）过程，完全可以类比成在几个基本前提下不断演算出其他推论，并以它们为新前提继续演算的过程。最终结果的正确性也就完全取决于所有前提的正确性。因此 TDD 天然就是自底向上的。

由于我们只需要验证前提正确即可，因此基于属性的测试（property-based testing) 就比依靠枚举的基于样例的测试 (example-based testing) 要严谨一些，需要的代码工作量也要少得多。因此，除了掌握基本的基于样例的测试框架，如 gtest for C++, junit for Java，一些基于属性的测试框架也可以考虑试用一下（虽然目前部分 port 还不大成熟），比如：

- CppQuickCheck for C++
- ScalaTest for Scala/Java
- JunitQuickCheck for Java

### 构建 (building)

构建及安装的过程完成了从仓库零件组装成具备功能的组件再回流到系统资源仓库的过程，从此组件成为系统生态的一部分，而整个开发过程也实现了闭环。这里的资源仓库也可以是广义的，比如你用 `gcc` 编译一个 C 源码，`clib` 的函数便是仓库组件，编译的可执行文件便是新组件，而安装（也即部署）的过程，即是让新组件回流到本地的应用仓库 `/usr/local/bin` 的过程。

当系统足够复杂时，我们便需要构建系统。比如对 C/C++ 来说，他们缺乏一个模块系统来抽象链接的过程，所以我们需要用 `CMake` 来填补这个系统缺失。在有些模块化的语言里，模块化的抽象还不够彻底，比如 Java，我没有对资源和配置的比较好的模块化抽象，所以我们有了 `Maven`。在这方面，我认为 `webpack` 做的是最好的，它提供的开发的可插拔式的模块系统，让我们可以表示任意"依赖"关系的抽象。这种依赖，既可以是系统的原语本身，也可以是一个资源，一段配置，或者是其他的语言代码或者干脆是自己定义的新语言的代码。

当用户具备了测试和构建的能力时，用户才算真正具备了利用系统进行创造的能力。假以时日，当用户终于创造出对其他用户有意义的组件时，他便可以考虑学习系统的 发布 (publishing) 相关了。这个学习发布的时间点个人认为可以适当延后，不然照现在各系统越来越便捷的发布能力来看，一不小心一个系统的仓库就得塞满组件变得像 npm 那样了（此处应有滑稽脸）。

## 当设计一个新系统时我们该关心什么？

我认为对一个系统来说最重要的就是正交性 (orthogonality) ，至少是在设计之初是最重要的。因为我们要考虑到我们为什么要设计一个新系统，那想必是因为问题足够大足够复杂。而正交性则是控制系统在模型层面保持简洁的重要手段（如果不是唯一的话）。

有了正交性，我们设计系统的过程就可以简化成以下几个步骤：

1. 定义几个互相独立的原子组件；
2. 定义原子之间的交互法则；
3. 用上面的条件构建出整个系统。

目前来说，物理学家倾向于相信宇宙的模型是满足这个构成方式的。lambda 演算模型也是满足这个构成方式的。因此，我们可以用几页公式就定义了整个宇宙模型，用更少的几个公式就定义了 lambda 演算模型。而对于那些不符合正交性的模型，那些特殊情况就像英文语法里的特殊时态变形一样，徒增系统的复杂度。举个最有名的例子，就是 C 语言的设计。

考虑 C 语言的两类原子，一种是类型 （type），类型与类型之间不存在交互；一种是类型操作符 (type op)， 操作符能作用于类型上形成新的类型。比如：`*` 作用于 `int` 上，形成新的类型 `int*`。现在我们考察一下它们的正交性：

|              | int  | void | array | poineter | function parameter | function return type |
| ------------ | ---- | ---- | ----- | -------- | ------------------ | -------------------- |
| **int**      | N/A  | N/A  | O     | O        | O                  | O                    |
| **void**     |      | N/A  | X     | O        | X                  | O                    |
| **array**    |      |      | O     | O        | X                  | X                    |
| **pointer**  |      |      |       | O        | O                  | O                    |
| **function** |      |      |       |          | X                  | X                    |

可以看到，C 的正交性相当差劲。在表中被标为 `X` 的地方即是不满足正交性的地方，同时，每一个`X`所在的交叉点，基本上都是 C 新手常常迷惑且容易犯错的地方。可以说其语言设计上的不规则，其危害最终却转嫁到每一个系统的学习者身上了。

> 题外话，从上表上我们实际就能看出 C 语言的类型系统究竟是怎样的了。可以说就是几种原始类型加指针才是真正的类型；而 void 也好，数组也好，函数也好，都不是真正的类型，他们都是指针类型的语法糖而已。下次有人若问你 C 里函数是不是一等对象的时候，就不要一脸懵逼地说函数能作为参数传入啊——传入的只是指针而已；数组同理。

另外我们发现正交性好的模型，比如 RISC 指令集，比如 Haskell，他们的规则性甚至能够让性能的优化变得更为容易。不过这也引发一个问题，就是当原子粒度足够细的时候，模型的简化带来的是拓扑的过度复杂。当然衡量是否过度的标准是以人类能否轻松处理来定义的。为了让人类能应付这种复杂性增加，我们才需要层级抽象，才需要封装。可以说层级和封装都是源于人类的生理限制的，而正交性才是系统的根本属性。

当然，上面举的例子里，我们会发现模型的简洁源于问题足够 clean 或者设计者刻意保证问题的纯粹性 (Haskell)。而 C ，就是既不 clean 又 impure 的例子。我们在真实的 dirty 的世界里，真的都能构建出足够简洁的系统来吗？我没有确切的答案，但至少，现在比过去做的好多了。