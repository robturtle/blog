---
title: 封装，状态与数据类
date: 2016-07-12 22:06:53
tags:
- java
- OO
---

要回答为什么需要封装，首先需要回答另一个问题：什么是状态？

关于第二个问题，轮子哥的回答最为精当：“状态即不变式”。

考虑有一个类：

```java
class Integer {
  public int value;
  int get() { return value; }
  void set(int now) { value = now; }
}
```

当我们需要一个具有不同 `value` 的值的时候，我们可以调用它的 `setter` 来做到：

```java
Integer a = new Integer(1);
a.set(2);
```

但我们并不认为这个类具有状态，因为上面的修改操作，完全等价于用一个新常量覆盖掉旧的，像这样：

```java
class Integer { public final int value; }
Integer a = new Integer(1);
a = new Integer(2);
```

当且仅当类内部具有某种不变式逻辑的时候，我们才认为该类具备状态：

```java
class List { int[] data; int size; }
```

其中 `List` 里满足 `size == length of data` 的不变式。若用户具备单独修改 `size` 或 `data` 的能力的时候，不变式就会被破坏。因此我们需要将二者与用户隔离开，保证所有合法操作的原子性。

显然，对不变式的维护需要付出成本。权限检查只是小事，另一件关键点在于，对不变式的维护天然是同步的，而同步是于并发矛盾的。为了让我们的程序对并发友好，就有必要把持有状态的类的数量限制在一个足够小的规模。而那些不具备状态的类，实质上只是一段只读的数据而已。在历史上这个概念有许多不同的名字：

- C 里的 struct （它本来的名字叫 record，对数据这一内涵的表达非常明显）
- Scala 里的 data class

特别提一下 Java 8 具备的成员变量隐含为 `final` 的特性，这让你在 Java 8 里定义的所有的不含成员变量赋值语句的类都默认为数据类了。

有人会说在语言里这样每当需要修改数据类的时候就用新实例覆盖的方式会 GC 不友好。但我们一开始也提过了数据类的变量修改和不变量覆盖是完全等价的，所以我们的编译器完全可以做直白的优化，在实际运行时将不变量覆盖重新转换为变量修改。比如我们可以在执行 `a = new Integer(2)` 这句的时候，先检查 `a` 指向实例的引用计数。当发现引用计数为 1 的时候，我们就可以安全地在底层忽略 `final` 执行 `a.value = 2` 而不是创建一个新的实例咯。所以，引入数据类的概念不但有利于并发，还不会带来额外的运行开销。

总结一下，状态即对象内部需要维持的不变式，在用户层面维持的充分条件是封装，在运行层面维持的必要条件是同步。为了并发友好，我们有必要有意优先使用无状态的数据类。恩，这就是 “immutable” 大行其道的原因啦。