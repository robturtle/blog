---
title: Type V.S. Concept & Covariance V.S. Contravariance
date: 2016-06-26 08:24:26
tags:
- PL
---

 ## Type V.S. Concept

由于暂时没见过中文对 concept 的翻译，所以暂粗浅地将它翻译为概念。

先说类型，什么是类型呢？ 若追本溯源来说，数据一开始是没有类型的，早古时期的计算机科学家为了算弹道，发明了向量结构存储中间结构，什么二维矩阵几行几列存的是整数还是浮点数，通通靠设计者的脑补。此时大家对计算机还只是一个 data processor 的概念。后来在高级语言萌芽的过程里，人们发明系统地将某块内存标记上它所代表的数据含义，是个提高效率的好方法。这便是类型的原始意义。

<!-- more -->

为了避免程序出错，他们选择了在函数的签名里加上了类型的约束。如果参数声明为 int 类型，那么这个函数就只能接受被标记为 int 类型的数据作为输入。（可以说这个设计从一开始就走错方向了，当然，现在也只能说这是历史的局限性了）这种约束并不是个好方案，因为有些函数是超越类型的。比如我要实现一个加法函数，它应当能既处理 int 又能处理 double ，我们的语言应当能提供这种灵活性。然后嘛，他们就推出向上隐式转换的最朴素的子类型系统了。

然后进入 GUI 时代，OO 风流行，一整完整的基于子类型的类型系统被发明。里式变换法则总结了合法的变换规律。但不管变得多么复杂，类型的核心意义还是基本没变，它回答的就是一个“这段数据代表什么”的问题。换句话说，类型约束的问题依然存在，它只能声明一个函数能处理 A 类型及其子类型的数据。对于超越类型的泛化函数还是一点办法没有。而声明泛化函数的表达力是如此之强另语言作者不得不考虑，没有办法了，那就开个后门吧。于是他们提供了让使用者选择性绕过类型约束的方案：

```c
void qsort(void *prt, size_t count, size_t size);
```

就是一个小小的语言决策，C 变成了动态的弱类型语言。基本上说它从类型系统里获益的有限，又引入了一个萦绕 C 使用者多年的噩梦 -- Access Violation。

后来人们慢慢发现了，这些超越类型的函数，它们根本不关心传入的是什么类型，但它们还是有内在的另一种约束，那就是：传入的实体支持什么操作。比如这个排序，但凡是一个能比较大小的类型，都能被排序。这种能够比较大小的属性，我们便称为 concept 。要注意，其实它的本质内涵和类型已经差了很远了。但是语言设计者们本着如无必要勿增实体的原则，在类型系统上略有些别扭地实现了 concept 这个概念。其中以 C++ 最早也最扭曲，它引入了虚类，虚继承，和多重继承（因为一个数据只能是一种类型但可以满足多个概念）。而后的 Java 和 C# 则引入了 interface。（本来 C++17 是有望引入 concept 进标准的，现在只能，唉 ╮(╯▽╰)╭）

概念系统其实是比类型系统更适合用来当做约束的，它比类型约束更灵活也更抽象，具有更好的概括能力和更宽泛合理的约束，它使得实现接口时我们不必再拘泥于特定的数据布局，而只关心数据能用来做什么，于是所有支持这个概念的类型，都能自然地输入进这个接口。这便是为什么 interface oriented 要比 OO 更受推崇的原因。事实上，如果概念在一开始就做为唯一的约束系统，我们的语言里连泛型都可以完全不需要了。但我们至少可以基于现有系统做一些微小的工作，比如在自己的代码里尽量用 interface 来表达参数约束，来让这个世界更加美好。


## Covariance V.S. Contravariance

这个是基于上文的里式变换的，定义 A <= B 为 A 是 B 的子类型，如果对任意 A a ， 都可以被看作是一个 B，那么它就是协变(Covariant)的；反之，如果对任意一个 B b, 都可以被看作是一个 A，那么它就是逆变(Contravariant)的；如果A 就只能是 A，B 就永远只能是 B，那么它就是不变(Invariant)的。在里式变换下，对于单个值类型来说，协变是天然合法的，逆变则是类型不安全的。以下的讨论基本都源于此规则。

假设我们有一种语言，用 <=A 来表达这是 A 的协变类型， >=A 表达逆变类型，==A 表达不变类型。那么我们可知，对 <=A 来说，我们可以合法地读取它的内容存入 A ，因为 <=A 对于 A 来说是协变的，但反之，我们无法将 A 存入 <=A ，因为 <=A 可以是 A 的任意子类型。所以我们说协变的类型，是 **只读** 的，是负责 **输出(out)** 的。反过来说，对于逆变的类型，它就是 **只写** 的，是负责 **输入** 的。如果我们希望一个类型既可读又可写，那么它只能是不变的。

现在考虑数组类型，它显然有把数据写入的需求，也显然有读出的需求，那么，数组只有在它是不变类型的情况下它才会是类型安全的。可是，由于我们的语言设计者错误地把类型而不是概念当做了接口约束，又还没来得及找到泛型这个补丁，我们就没办法对一个不变类型写出超越类型的泛化函数了！比如一个打乱数组顺序的函数，我们实际希望它的约束是：

```java
void shuffle(<=Object[] ary);
```

但因为语言不支持这种表述，我们就只能从类型系统上又开个洞，我们让数组类型变成协变的了。那我声明接受一个 Object[] 的参数，所有 Object 子类型的数组参数也能被接受咯。

那它因此带来的类型不安全问题怎么办呢？比如像这样：

```java
Animal[] a = new Cat[1];
a[0] = new Dog();
```

这便是广为人知的 cat shelter 问题。Java 和 C# 无奈地说到，只好在运行时动态检查动态抛异常咯。（那也比 C 因为 AV 一言不和就 segfault 要好不是）

所以啊，我们现在有了泛型，在真的需要数组的时候，还是把它们当成是一个不变的类型来用，不要再去碰他们因为历史原因而开的脑洞，那才是最吼滴。

讲了协变，好像逆变平时比较少见点。那是因为，大部分平常接触的都是非函数式语言啊，而逆变最常见的地方就是在把函数当做变量时的函数类型上。如果函数 f 类型是 A -> B ，另一个函数 g 是 A -> C ， C<=B，那么显然 g 对 f 是协变的，因为返回值可以安全地看作是 A 咯；另一方面，如果函数 k 是 D -> B，D>=A，那么 k 对 f 也是协变的，因为虽然 k 的接口更宽泛，但它赋给了 f 之后，它也自然要受 f 的约束咯，所以还是合法的。总结起来就是，如果一个函数的参数是逆变的，返回值是协变的，那么这个函数就是协变的。

虽然 C++，Java，C# 函数都不是变量，但它们 override 的时候，还是要接受类似的类型检查嘛。所以它们在经历了若干个标准过后，终于醒悟过来，确定了返回类型如果返回一个协变类型也是一个合法的 override 这一规则。可是参数的逆变规则，直到现在它们都没有支持，因为这太，唔，函数式了么？

至于对于更高阶的协变规则，比如对高阶函数 (A->B)->C ，它的协变规则应该是什么样子呢？更高阶的呢？反正我的脑袋已经炸了，感兴趣的童鞋可以自己推推看。

最后讲一讲泛型吧，Java 的泛型是不变类型的 (此处应有一个生无可恋脸），因此在泛型的类型变量里，所有你以为存在的继承关系（即协变关系）都不存在了。那我怎么在不绕过泛型系统的情况下实现协变和逆变？答案是，Java 提供了 ? extends 和 ? super 的关键字咯。因此，对于一个二维的可遍历概念来说，Java 得这么写：

```java
Iterable<? extends Iterable<String>> i = new ArrayList<ArrayList<String>>();
```

而对于 C#， 它则让你在声明 interface 的时候，注明它是三种协变类型的哪一种，所以 C# 里可以直接写 `IEnumerable<IEnumerable<String>>` 没问题咯
